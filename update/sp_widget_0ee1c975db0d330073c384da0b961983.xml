<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>custom</category>
        <client_script><![CDATA[function($rootScope,$scope,spUtil) {
	/* widget controller */
	/*
	Client-side API
The client-side Widget API classes are:

spUtil: Contains utility methods to perform common functions in a Service Portal widget client script. Access the methods from this class using spUtil. For example, spUtil.addErrorMessage().
addErrorMessage(): display an error message
addInfoMessage(): display an informational message
addTrivialMessage(): display a message which automatically disappears after a short period of time
format(): used to build strings from variables (alternative to concatenation)
get(): gets a widget model by ID or sys_id
recordWatch(): watches for updates to a table or filter and returns the value from a callback function
refresh(): calls the server and replaces the current options and data objects with the server response
update(): updates the data object on the server within a given scope
spModal: Methods provide an alternative way to show alerts, prompts, and confirmation dialogs. Access the methods from this class using spModal. For example, spModal.alert().
alert(): displays an alert
confirm(): displays a confirmation message
open(): opens a modal using the specified options
prompt(): displays a prompt for user input
spAriaUtil: Uses an AngularJS service to show messages on a screen reader. Access the method from this class using spAriaUtil. For example, spAriaUtil.sendLiveMessage().
sendLiveMessage(): announce a message to a screen reader
For the complete API documentation, including method arguments and return values, follow the links to the API classes.


Client-side Debugging
The client-side Widget API includes methods which can be used for logging/debugging:

spUtil.addErrorMessage()
spUtil.addInfoMessage()
spUtil.addTrivialMessage()
spModal.alert()

Using the Client-side Widget API
In an earlier part of this module, you learned there are three client-side Widget APIs:

spUtil: Contains utility methods to perform common functions in a Service Portal widget client script.
spModal: Methods provide an alternative way to show alerts, prompts, and confirmation dialogs.
spAriaUtil: Uses an AngularJS service to show messages on a screen reader.
In order to use classes from the client-side Widget API, the global object for the API must be passed as a dependency to the Client Script. The Client Script creates the AngularJS controller using the passed in dependencies.

If a Client Script attempts to use a client-side Widget API without passing the dependency, a ReferenceError occurs at runtime.


Using AngularJS Events with Widgets
AngularJS uses a publish and subscribe strategy for handling events. Events are useful for notifying widgets about important things happening in other widgets. For example:

Record selected
Changed value
Data deleted
Data added
And more....
Work with events in AngularJS using these functions:

$emit(): Send an event up the scope hierarchy
$on(): Listen for events of a given type
DEVELOPER TIP: Avoid the use of $rootScope.$broadcast() because it can cause performance issues.

$rootScope.$emit("eventName",{})--event-->$rootScope---event-->$rootScope.$on("eventName", function(event, dada)){}

recordWatch()
In the CreateNotes widgets, you are able create, update, and delete Notes records. What happens in the widgets if a 
user creates a record using the standard ServiceNow UI (UI16)?

Although the Notes List and Notes Body widgets have been developed to communicate with each other, 
they are not notified of changes made to the Create Notes table records when the interaction happens 
through the standard ServiceNow UI.

Use the Client API method spUtil.recordWatch() to register a listener in a widget. The listener is 
notified when table records are inserted, deleted, or updated

spUtil.recordWatch($scope, "table_name", "filter", function(name) {
		console.log(name); //Returns information about the event that has occurred
		console.log(name.data); //Returns the data inserted or updated on the table
	  });
	}

spUtil.recordWatch($scope,"incident","active=true",function(name){

	// listen for changes to incident table records where the record is active i

		console.log(name); //Returns information about the event that has occurred
		console.log(name.data); //Returns the data inserted or updated on the table
	  });
	}

	//GET QUERY FROM QUERY BUILDER
	spUtil.recordWatch($scope,"incident","caller_idDYNAMIC90d1921e5f510100a9ad2572f2b477fe^active=true",function(name){

		console.log(name.data.operation); 
		console.log(name);
	});
	*/

	var c = this;
	// Use a position indicator to know which record to update
	c.notePos = 0;
	//spUtil.addInfoMessage("Welcome");

	//----------------------------------------------------------------------
	// CREATE
	//-----------------------------------------------------------------------
	c.newNote = function() {
		c.server.get({
			action: 'newNote'
		}).then(function(r) {
			c.data.notes.unshift(r.data.newNote);
			c.data.noteID = r.data.noteID;
			$rootScope.noteID = c.data.noteID;
			$rootScope.$emit('selectNote', c.data.noteID);
		});
	}


	c.selectItem = function(idx) {//powerful tool

		// Set the position indicator to the index value passed in on select
		c.notePos = idx;
		var id = c.data.notes[idx].sys_id;
		console.log('Note ID: ' + id);
		$rootScope.noteID = id;
		$rootScope.$emit('selectNote', id);
		$rootScope.$broadcast('selectNote2', {"sys_id" : id});

	}


	//-----------------------------------------------------------
	// RECORD UPDATED BY OTHER WIDGET
	//-----------------------------------------------------------
	// Subscribe to event.  Set the new title and note values on the 
	// c.data object
	$rootScope.$on('updateTitle', function(event,data) { 
		c.data.notes[c.notePos].title = data.title;
		c.data.notes[c.notePos].note = data.note;
	});



	//--------------------------------------------------------
	// RECORD DELETED IN THE BODY WIDGET
	//--------------------------------------------------------
	$rootScope.$on('deleteNote', function(event,data) {
		c.data.notes.splice($scope.notePos, 1);
	});


	// Record removed from data object on the client and passed to server
	c.snNoteUpdate = function(name,sysID){

		for (var i=0;i<c.data.notes.length;i++){
			if(c.data.notes[i].sys_id == name.data.sys_id){
				if(name.data.record.note){
					c.data.notes[i].note = name.data.record.note.display_value;
				}
				if(name.data.record.title){
					c.data.notes[i].title = name.data.record.title.display_value;
				}
				c.server.update();

			}
		}
	}

	// Record removed from data object on the server and passed back to client
	c.snNoteDelete = function(sysID){

		c.server.get({
			action: 'snDeleteNote',
			noteID: sysID

		}).then(function(r){
			c.data.notes = r.data.notes;
		});

	}

	//-------------------------------------------------------------------
	//  Use Record Watch
	//-------------------------------------------------------------------
	spUtil.recordWatch($scope, "x_snc_createnotes_note", "numberANYTHING", function(name) {
		console.log("OPERATION : "+name.data.operation); 
		console.log("NAME : "+name); 

		//  Respond to the Record Insert
		// Fast and easy... replace the client data object with the server data object
		if(name.data.operation == "insert"){
			c.server.refresh();
		}

		// Respond to Record Update and Delete - Client Script
		// Calls a Client Script function to do the update and pass the updated data object
		// to the server.
		if(name.data.operation == "update"){
			c.snNoteUpdate(name, name.data.sys_id);
		}


		// Calls a Client Script function which does the update on the server and passes
		// the updated data object back to the client.
		if(name.data.operation == "delete"){
			c.snNoteDelete(name.data.sys_id);
		}

	});








}]]></client_script>
        <controller_as>c</controller_as>
        <css/>
        <data_table>sp_instance</data_table>
        <demo_data/>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>true</has_preview>
        <id>notes_list</id>
        <internal>false</internal>
        <link/>
        <name>Notes List</name>
        <option_schema>[{"hint":"Specify a title for the Notes List widget","name":"title","section":"other","default_value":"NOTES NAV BAR","label":"Title","type":"string"},{"hint":"Select the maximum number of records to display","name":"maximum_records_to_display","section":"other","default_value":"5","label":"Maximum records to display","type":"choice","choices":[{"label":"2","value":"2"},{"label":"3","value":"3"},{"label":"5","value":"5"},{"label":"7","value":"7"},{"label":"11","value":"11"},{"label":"13","value":"13"},{"label":"17","value":"17"}]}]</option_schema>
        <public>false</public>
        <roles/>
        <script><![CDATA[(function() {
	/* populate the 'data' object */
	/* e.g., data.table = $sp.getValue('table'); */
	/*
	Server-side API
The server-side Widget API class is:

GlideSPScriptable: Methods for use in Service Portal widget Server Scripts. Access the GlideSPScriptable methods using the global $sp object. For example, $sp.canRead().
canReadRecord(): returns true if the user can read the specified GlideRecord
getCatalogItem(): returns a model and view model for a sc_cat_item or sc_cat_item_guide
getDisplayValue: returns the display value of the specified field from either the widget's sp_instance or sp_portal record
getField(): returns information about the specified field in a GlideRecord
getFields(): checks the specified list of field names, and returns an array of valid field names
getFieldsObject(): checks the specified list of field names and returns an object of valid field names
getForm(): returns the form
getListColumns(): returns a list of the specified table's columns in the specified view
getMenuHREF(): returns the (?id=) portion of the URL based on the sp_menu type
getMenuItems(): returns an array of menu items for the specified instance
getParameter(): returns the value of the specified parameter
getPortalRecord(): returns the portal's GlideRecord
getRecord(): returns the current portal context
getRecordDisplayValues(): copies display values for the specified fields into the data parameter
getRecordElements(): for the specified fields, copies the element's name, display value, and value into the data parameter
getRecordValues(): copies values for the specified field names from the GlideRecord into the data parameter
getStream(): gets the activity stream for the specified record. This method works on tables which extend the Task table
getUserInitials(): returns the user's initials
getValue(): returns the value of the specified parameter
getValues(): copies values from the request or instance to the data parameter
getWidget(): gets a widget by id or sys_id, executes that widget's server script using the provided options, then returns the widget model
For the complete API documentation, including method arguments and return values, follow the links to the API classes.


	Server-side Debugging
The server-side GlideSystem class includes methods which can be used for logging/debugging:

gs.log() - Global API
gs.logError() - Global API
gs.logWarning() - Global API
gs.warn() - Scoped API
gs.info() - Scoped API
gs.debug() - Scoped API
gs.error() - Scoped API
gs.addInfoMessage() - Scoped API and Global API
gs.addErrorMessage() - Scoped API and Global API



Widget Option Schema
Using widgets options makes widgets more easily reusable. The widget option schema defines 
the user-configurable fields. To add, edit, or delete option fields, select the Edit 
Options Schema menu item in the Widget Editor menu.
	*/



	//create an array to populate without notes
	data.notes = [];

	var noteGR = new GlideRecord('x_snc_createnotes_note');
	noteGR.addQuery('user', gs.getUser().getID());
	noteGR.orderByDesc('sys_created_on');
	noteGR.setLimit(options.maximum_records_to_display);
	noteGR.query();
	while (noteGR.next()) {
		var noteObj = {};
		//use service portal helper method to get some display values
		$sp.getRecordDisplayValues(noteObj, noteGR, 'number,title,sys_id');
		//get the first 20 characters of the description
		noteObj.note = noteGR.getValue('note');//.slice(0,20);
		//push the populated obj into the array
		data.notes.push(noteObj);
	}


	if (input) {
		if (input.action == 'newNote') {
			var newNote = new GlideRecord('x_snc_createnotes_note');
			newNote.newRecord();
			var id = newNote.insert();
			data.noteID = id;
			data.newNote = {};
			$sp.getRecordValues(data.newNote,newNote,"title,note,sys_id");

		}

		if (input.action == 'snDeleteNote') {
			var delNote = new GlideRecord('x_snc_createnotes_note');
			// The notes record should already be gone.  Just
			// making sure it no longer exists.
			if(delNote.get(input.noteID)){
				delNote.deleteRecord();
			}

		}
	}
})();






























]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2019-04-26 23:07:52</sys_created_on>
        <sys_id>0ee1c975db0d330073c384da0b961983</sys_id>
        <sys_mod_count>51</sys_mod_count>
        <sys_name>Notes List</sys_name>
        <sys_package display_value="CreateNotes" source="x_snc_createnotes">df5fd9a5090232007f44e1046c8ff69f</sys_package>
        <sys_policy/>
        <sys_scope display_value="CreateNotes">df5fd9a5090232007f44e1046c8ff69f</sys_scope>
        <sys_update_name>sp_widget_0ee1c975db0d330073c384da0b961983</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2019-04-27 16:39:52</sys_updated_on>
        <template><![CDATA[<div class="panel panel-default">
  <div class="panel-heading clearfix">
    <h3 class="panel-title pull-left">
      <!--${Notes}-->
      {{::c.options.title}}
    </h3>
    <button class="btn btn-default pull-right" ng-click="c.newNote()"> 
      <span class="glyphicon glyphicon-plus"></span> 
    </button>
  </div>
  <div class="panel-body"> 
    <input placeholder="Filter" class="form-control" ng-model="noteFilter" /> 
  </div>

  <div class="list-group">
    <a class="list-group-item" ng-click="c.selectItem($index)" ng-repeat="note in data.notes | filter: noteFilter">
      <h4 class="list-group-item-heading">
        {{note.title}}
      </h4>
      <p class="list-group-item-text">
        {{note.note}}
      </p>
    </a>
  </div>
</div>]]></template>
    </sp_widget>
</record_update>
